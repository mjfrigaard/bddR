---
title: "bdd-testthat"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{bdd-testthat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = " ",
  error = TRUE
)
```

This vignette covers how to use `bddR` functions with [`testthat`'s `describe()` and `it()` functions](https://testthat.r-lib.org/reference/describe.html).

```{r setup}
library(bddR)
```

Make sure you have the latest version of `testthat` installed.

```{r testthat, eval=TRUE}
if (!require(pak)) {
  install.packages("pak",
    repos = "http://cran.us.r-project.org"
  )
}
pak::pkg_install("r-lib/testthat", upgrade = TRUE, ask = FALSE)
library(testthat)
```

## Gherkin

Using [Gherkin keywords](https://cucumber.io/docs/gherkin/reference/) is possible in `test_that()` tests, it's just a lot of typing: 

```{r}
test_that(
  "Feature:
	  As a user
	  I want to see the changes in the plot
	  So that I can visualize the impact of my customizations",
  code = {
    expect_true(TRUE)
  }
)
```

`bddR` has helper functions for writing Gherkin-style `feature`s, `scenario`s, and `background`s. These can be placed in the test_that() description: 

```{r}
test_that(
  feature(
    title = "Visualization",
    as_a = "user",
    i_want = "to see the changes in the plot",
    so_that = "I can visualize the impact of my customizations"
  ),
  code = {
    expect_true(TRUE)
  }
)
```

They use the same level of indentation as Gherkin:

```{r collapse=TRUE}
feature(
  title = "Visualization",
  as_a = "user",
  i_want = "to see the changes in the plot",
  so_that = "I can visualize the impact of my customizations"
)
background(
  title = "Launching the application",
  given = "I have launched the application",
  and = list(
    "it contains movie review data from IMDB and Rotten Tomatoes",
    "the data contains variables like 'Critics Score' and 'MPAA'",
    "the data contains variables like 'Audience Score' and 'Genre'"
  )
)
scenario(
  title = "Viewing the Data Visualization",
  given = "I have launched the application",
  when = "I interact with the sidebar controls",
  then = "the graph should update with the selected options"
)
```

## BDD functions

The `describe()` function can hold any combinations of features or backgrounds: 

```{r}
describe(
  feature(
    title = "Visualization",
    as_a = "user",
    i_want = "to see the changes in the plot",
    so_that = "I can visualize the impact of my customizations"
  ), code = {
    
    describe(
      background(
        title = "Launching the application",
        given = "I have launched the application",
        and = list(
          "it contains movie review data from IMDB and Rotten Tomatoes",
          "the data contains variables like 'Critics Score' and 'MPAA'",
          "the data contains variables like 'Audience Score' and 'Genre'")
  ), code = {
    
    it(
      scenario(
        title = "Viewing the Data Visualization",
        given = "I have launched the application",
        when = "I interact with the sidebar controls",
        then = "the graph should update with the selected options"
      ), code = {
      
      expect_true(TRUE)
      
    })
  
  })
    
})
```

You can also `bundle()` features and backgrounds:

```{r}
describe(
  bundle(
    feature(
      title = "Visualization",
      as_a = "user",
      i_want = "to see the changes in the plot",
      so_that = "I can visualize the impact of my customizations"
  ),
    background(
      title = "Launching the application",
      given = "I have launched the application",
      and = list(
        "it contains movie review data from IMDB and Rotten Tomatoes",
        "the data contains variables like 'Critics Score' and 'MPAA'",
        "the data contains variables like 'Audience Score' and 'Genre'")
    )
), code = {
    it(
      scenario(
        title = "Viewing the Data Visualization",
        given = "I have launched the application",
        when = "I interact with the sidebar controls",
        then = "the graph should update with the selected options"
      ), code = {
      
      expect_true(TRUE)
      
    })
  
  })
```


## Tables

It's also possible to b a table in the scenario or feature. Assume we're testing a function, `sep_cols_mult()`, and we want to provide some example data in the scenario (stored in `input_data`):

```{r , echo=FALSE}
input_data <- data.frame(
  value = c(1L, 2L, 3L),
  name = c(
    "John", 
    "John, Jacob",
    "John, Jacob, Jingleheimer"
  )
)
```

```{r, comment="#>"}
input_data
```

We can convert input_data to a Gherkin-style table using `with_table()`:

```{r comment="#>"}
with_table(input_data)
```

`input_data` can be added into a `bundle()` with `background` and `feature`

```{r}
bundle(
  background(
    title = "Input dataframe with text data", 
    given = "a dataframe with text data", 
    and = list(
               "a column prefix", 
               "a specified column")),
input_data = c("
               |value |name                      |
               |------|--------------------------|
               |1     |John                      |
               |2     |John, Jacob               |
               |3     |John, Jacob, Jingleheimer |
               "),

feature(
  title = "Separate single column into multiple based on pattern", 
  as_a = "user of sep_cols_mult() ", 
  i_want = "to specify a separate column and a pattern to separate on", 
  so_that = "a resulting dataframe contains the new separated columns.")
)
```


In the tests for `sep_cols_mult()`, we know what we want the output table to look like, too: 

```{r}
scenario(
    title = "Split column with default pattern",
    given = "a dataframe with specified column [name]",
    when = "I split the [name] column with the default pattern",
    then = "the [name] column should be split into multiple columns"
  )
```


```{r , echo = FALSE}
output_data <- 
data.frame(value = 1:3, name = c("John", "John, Jacob", "John, Jacob, Jingleheimer"
), col_1 = c("John", "John", "John"), col_2 = c(NA, "Jacob", 
"Jacob"), col_3 = c(NA, NA, "Jingleheimer"))
```

So we'll provide and example `output_data`, too: 

```{r, comment="#>"}
output_data
```

So we'll include `output_data` in another `bundle()` with the `scenario`:

```{r , eval=FALSE, echo=TRUE}
with_table(output_data)
```

```{r , eval=TRUE, echo=FALSE}
with_table(output_data)
```


```{r}
bundle(
output_data = c("
                |value |name                      |col_1 |col_2 |col_3        |
                |------|--------------------------|------|------|-------------|
                |1     |John                      |John  |NA    |NA           |
                |2     |John, Jacob               |John  |Jacob |NA           |
                |3     |John, Jacob, Jingleheimer |John  |Jacob |Jingleheimer |
              ")
)
```


```{r}
bundle(
  background(
    title = "Input dataframe with text data", 
    given = "a dataframe with text data", 
    and = list(
               "a column prefix", 
               "a specified column")),
input_data = c("
               |value |name                      |
               |------|--------------------------|
               |1     |John                      |
               |2     |John, Jacob               |
               |3     |John, Jacob, Jingleheimer |
               "),
feature(
  title = "Separate single column into multiple based on pattern", 
  as_a = "user of sep_cols_mult() ", 
  i_want = "to specify a separate column and a pattern to separate on", 
  so_that = "a resulting dataframe contains the new separated columns."),
  
scenario(
    title = "Split column with default pattern",
    given = "a dataframe with specified column [name]",
    when = "I split the [name] column with the default pattern",
    then = "the [name] column should be split into multiple columns"
  ),
output_data = c("
                |value |name                      |col_1 |col_2 |col_3        |
                |------|--------------------------|------|------|-------------|
                |1     |John                      |John  |NA    |NA           |
                |2     |John, Jacob               |John  |Jacob |NA           |
                |3     |John, Jacob, Jingleheimer |John  |Jacob |Jingleheimer |
              ")
)
```



```{r}
describe(
bundle(
  background(
    title = "Input dataframe with text data", 
    given = "a dataframe with text data", 
    and = list(
               "a column prefix", 
               "a specified column")),
input_data = c("
               |value |name                      |
               |------|--------------------------|
               |1     |John                      |
               |2     |John, Jacob               |
               |3     |John, Jacob, Jingleheimer |
               "),

feature(
  title = "Separate single column into multiple based on pattern", 
  as_a = "user of sep_cols_mult() ", 
  i_want = "to specify a separate column and a pattern to separate on", 
  so_that = "a resulting dataframe contains the new separated columns.")
), code = {
    
it(
bundle(
  scenario(
      title = "Split column with default pattern",
      given = "a dataframe with specified column [name]",
      when = "I split the [name] column with the default pattern",
      then = "the [name] column should be split into multiple columns"
    ),
  output_data = c("
                  |value |name                      |col_1 |col_2 |col_3        |
                  |------|--------------------------|------|------|-------------|
                  |1     |John                      |John  |NA    |NA           |
                  |2     |John, Jacob               |John  |Jacob |NA           |
                  |3     |John, Jacob, Jingleheimer |John  |Jacob |Jingleheimer |
                ")
  ), code = {
  
  observed <- sep_cols_mult(data = input_data, col = 'name')
  
  expect_equal(object = observed, expected = output_data)
  
})

})
```

