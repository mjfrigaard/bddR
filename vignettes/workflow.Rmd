---
title: "Workflow"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# Make sure you have the latest version of `estthat and sloop installed.
# if (!require(sloop)) {
#   install.packages("sloop",
#     repos = "http://cran.us.r-project.org"
#   )
# }
# pak::pkg_install("r-lib/sloop", upgrade = TRUE, ask = FALSE)
# 
# if (!require(pak)) {
#   install.packages("pak",
#     repos = "http://cran.us.r-project.org"
#   )
# }
# pak::pkg_install("r-lib/testthat", upgrade = TRUE, ask = FALSE)
```

```{r pkgs}
library(pickler)
library(testthat)
```


## Test development workflow

In standard R packages, new functionality is added to `R/` with `usethis::use_r()`, followed by a corresponding test file in `tests/testthat/` with `usethis::use_test()`:

-   [x] `use_r()`

-   [x] `use_test()`

While developing, these files can be accessed using the functions above, and tested interactively with `devtools::test_active_file()` and `devtools::test_coverage_active_file()`

-   [x] `test_active_file()`

-   [x] `test_coverage_active_file()`

As the code in `R/` grows, the test suite might include additional features like fixtures, helpers, mocks, or a `setup.R` file. When a package has been sufficiently developed, the tests are run with `devtools::test()`, test coverage is reported with `devtools::test_coverage()`, and the (I'm assuming the package is checked periodicaly with `devtools::check()`, too):

-   [x] `test()`

-   [x] `test_coverage()`

Additional package can be used to include test coverage reports ([`covrpage`](https://yonicd.github.io/covrpage/)), traceability matrices ([`covtracer`](https://genentech.github.io/covtracer/)), etc., to your package documentation.

Throughout development, the functional requirements for your package are documented in `R/` (with `roxygen2`), and long-form documentation is placed in vignettes.[^r-pkgs-vignettes] Vignettes can (and should) be used to show users how your package works, especially if your package is going to be shared with the world (i.e., via a [`pkgdown` site](https://pkgdown.r-lib.org/)). However, it's not often developers use vignettes to store the information that's essential to the development *process* (i.e., proposed features, specficiations, user stories, etc.) 

[^r-pkgs-vignettes]: The [vignettes](https://r-pkgs.org/vignettes.html#advice-on-writing-vignettes) chapter in R Packages, 2ed is a wonderful guide on writing that extends far beyond R packages.

## Behavior-driven development functions

`testthat`'s BDD functions (specifically `describe()`) allow us to include additional context for tests directly preceding the call to `it()` or `test_that()`. It's a little unorthodox, but we can compare the output of passing it() and `test_that()` tests using `waldo::compare()` (the underlying package used in functions like `expect_equal()`). 

```{r collapse=TRUE}
waldo::compare(
  test_that("make sure we did the thing right", {
    expect_equal(object = TRUE, expected = TRUE)
  }), 
    it("make sure we did the thing right", {
      expect_equal(object = TRUE, expected = TRUE)
  })
)
```

The 'secret sauce' of `test_that()` and `it()` is the ability to run `expect_*()` functions and return the logical (`TRUE`/pass or `FALSE`/fail). 

```{r collapse=TRUE}
unclass(
  test_that("make sure we did the thing right", {
    expect_equal(object = TRUE, expected = TRUE)
  })
)
unclass(
    it("make sure we did the thing right", {
      expect_equal(object = TRUE, expected = TRUE)
  })
)
```

If we attempt to `unclass()` the results of a failing test, we see an error is triggered (and both `actual` and `expected` values e sent off to `waldo::compare()`:

```{r, error=TRUE}
unclass(
  test_that("make sure we did the thing right", {
    expect_equal(object = FALSE, expected = TRUE)
  })
)
unclass(
    it("make sure we did the thing right", {
      expect_equal(object = FALSE, expected = TRUE)
  })
)
```

The `TRUE`/`FALSE` result is at the heart of all unit tests (i.e., "do the results meet my expectations?" Check 'yes' or 'no'). 

However, what happens if we wrap the same tests in `describe()`?

```{r collapse=TRUE}
unclass(
  describe("verify we implemented the right thing", {
    it("make sure we did the thing right", {
      expect_equal(object = TRUE, expected = TRUE)
    })
  }))
unclass(
  describe("verify we implemented the right thing", {
    test_that("make sure we did the thing right", {
      expect_equal(object = TRUE, expected = TRUE)
    })
  })
)
```

We can see `describe()` returns a `NULL` value instead of the logical comparison from `expect_equal()` (but it still returns the results of the test).

### Why should I care?

I'll use a known issue with `expect_snapshot()` and `test_that()` to demonstrate how `describe()` saves the day. Assume we have a function that generates output too complex to test with `expect_equal()`:

```{r, comment="#>"}
pickler_logo()
```

We don't want to visually inspect differences in `pickler_logo()`, so we'll use a snapshot test to capture a baseline for comparison. Let's start with `test_that()`

### Initial test_that() snapshot test

I've included a feature description in the `desc` argument for `pickler_logo()`:

```{r, eval=FALSE}
test_that("
  Feature: Text-based Logo Generation
  As a As a user who calls the pickler_logo() function
  I want to generate a text-based logo
  So that I can quickly insert the pickler logo", code = {
        expect_snapshot(pickler_logo())
      })
```

```{r ,eval=FALSE}
devtools::test_active_file()
```

After the initial call to `test_active_file()`, `testthat` tells us the location of the snapshot file is `tests/testthat/_snaps/`:

```markdown
# Feature: Text-based Logo Generation
  As a As a user who calls the pickler_logo() function
  I want to generate a text-based logo
  So that I can quickly insert the pickler logo

    Code
      pickler_logo()
    Output
      
                   d8b          888      888
                   Y8P          888      888
                                888      888
          88888b.  888  .d8888b 888  888 888  .d88b.  888d888
          888 "88b 888 d88P"    888 .88P 888 d8P  Y8b 888P"
          888  888 888 888      888888K  888 88888888 888
          888 d88P 888 Y88b.    888 "88b 888 Y8b.     888
          88888P"  888  "Y8888P 888  888 888  "Y8888  888
          888
          888
          888
          

```

### Subsequent test_that() test runs

Later we decide to change `pickler_logo()` by replacing the `\"` with `'`. After loading the changes, we notice that when we run the test again a *new snapshot file* is generated (and updated with the a new version of the logo):

```markdown
# Feature: Text-based Logo Generation
  As a As a user who calls the text_logo() function
  I want to generate a text-based logo
  So that I can quickly insert the pickler logo

    Code
      pickler_logo()
    Output
      
                   d8b          888      888
                   Y8P          888      888
                                888      888
          88888b.  888  .d8888b 888  888 888  .d88b.  888d888
          888 '88b 888 d88P'    888 .88P 888 d8P  Y8b 888P'
          888  888 888 888      888888K  888 88888888 888
          888 d88P 888 Y88b.    888 '88b 888 Y8b.     888
          88888P'  888  'Y8888P 888  888 888  'Y8888  888
          888
          888
          888
          

```

However, if the contents of `desc` are placed in the `description` argument of `describe()`, we see `testthat` detects the changes and asks us to review the snapshots.[^desc-expect-snapshot-issue]

[^desc-expect-snapshot-issue]: This currently [an open issue on GitHub](https://github.com/r-lib/testthat/issues/1900#issue-1995181567), but it looks like this [can be solved with `paste()`](https://github.com/mjfrigaard/shinyap/issues/18#issuecomment-1816626915)


```{r eval=FALSE}
describe(
  "Feature: Text-based Logo Generation
    As a user who calls the text_logo() function
    I want to generate a text-based logo
    So that I can quickly insert the pickler logo", code = {
      test_that("pickler_logo()", code = {
        expect_snapshot(pickler_logo())
      })
})
```

```{r ,eval=FALSE}
devtools::test_active_file()
```


```{verbatim}
[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]

── Failure (test-pickler_logo.R:8:9): pickler_logo ─────────────────────────────
Snapshot of code has changed:
old[6:15] vs new[6:15]
                 Y8P          888      888
                              888      888
        88888b.  888  .d8888b 888  888 888  .d88b.  888d888
-       888 "88b 888 d88P"    888 .88P 888 d8P  Y8b 888P"
+       888 '88b 888 d88P'    888 .88P 888 d8P  Y8b 888P'
        888  888 888 888      888888K  888 88888888 888
-       888 d88P 888 Y88b.    888 "88b 888 Y8b.     888
+       888 d88P 888 Y88b.    888 '88b 888 Y8b.     888
-       88888P"  888  "Y8888P 888  888 888  "Y8888  888
+       88888P'  888  'Y8888P 888  888 888  'Y8888  888
        888
        888
        888

* Run testthat::snapshot_accept('pickler_logo') to accept the change.
* Run testthat::snapshot_review('pickler_logo') to interactively review the change.
[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]
```

This is an example of how `describe()` gives us the ability to include context for tests (while keeping the scope confined to the tests within each `describe()` call). 

### BDD Recap 

Multiline descriptions in the `desc` argument of `test_that()` can cause issues when used wtth `expect_snapshot()`, but wrapping multiple lines in a call to` describe()` prevents the test from overwriting the baseline snapshot file.

The functionality provided by `describe()` is an excellent improvement to `testthat` tests, because we're no longer confined to comments and the `desc` argument of `test_that()` to document what *exactly* the test is testing. 

## Rmd + BDD = `pickler` 

Including relevant context in `describe()` and `it()` is nice for developers, but I've found stakeholders and potential users rarely look the the `tests/` folder for information on a package's features (or how it's functions are supposed to behave).

`pickler` was written to make the information in the `tests/` folder more accessible to a broader audience. The [Gherkin-style](https://cucumber.io/docs/gherkin/reference/) functions availble in `pickler` are designed to work in R Markdown (i.e. as a vignette) *and* run in a test file. It's been pointed out elsewhere[^2] that vignettes have a few characteristics that make them a great place for development:

<br>

> ***"an R package implies writing documentation: one of the main goals of the Vignettes, in an R package, is to document how to use the package. And the good news is that when checking a package, i.e. when running `check()` from `devtools` ([Wickham, Hester, and Chang 2020](https://devtools.r-lib.org/)) or `R CMD check`, the Vignettes are going to be built, and the process will fail if at least one of the Vignettes fails to render. That way, you can use the documentation of the back-end as an extra tool for doing unit testing!"***

<br>

[^2]: This point in made in [Engineering Production-Grade Shiny Apps](https://engineering-shiny.org/building-ispum-app.html#rmd-vignettes-and-documentation-first), and although the text is geared towards developing a Shiny app-package, the quote is also applicable to non-Shiny R packages. 


```{r , eval=FALSE, include=FALSE, comment=""}
feature(
    title = "Text-based Logo Generation",
    as_a = "As a user who calls the text_logo() function",
    i_want = "to generate a text-based logo",
    so_that = "I can quickly insert the pickler logo"
    )
```
